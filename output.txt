==== ./main.py ====
from lib.Player import Perspective, Player
from lib.Poker import Poker
from lib.Round import Round
from piwo1 import Piwo1
import logging
import os

def setup_logging():
    level_name = os.getenv("LOG_LEVEL", "INFO").upper()
    logging.basicConfig(
        level=getattr(logging, level_name, logging.INFO),
        format="%(asctime)s | %(levelname)-7s | %(name)s | %(message)s",
        datefmt="%H:%M:%S",
    )

if __name__ == "__main__":
    setup_logging()
    log = logging.getLogger("main")

    log.info("=== Start gry ===")

    p1 = Piwo1(name="Piwo1_bot", history=[], money=1000, hand=None, perspective=Perspective([], 0, []))
    p2 = Player(name="Tylko_call",   history=[], money=1000, hand=None, perspective=Perspective([], 0, []))
    players = [p1, p2]

    # Poker init
    poker = Poker(players)
    poker.initializeDeck()
    poker.dealCards()
    log.info("Karty rozdane graczom (szczegóły rąk w DEBUG).")

    # First round
    rnd = Round(poker, players, small_blind=10, big_blind=20)

    # Preflop
    log.info("— Preflop —")
    rnd.bidding_run()

    # Flop
    log.info("— Flop —")
    poker.burn(1)
    poker.addCards(3)
    rnd.bidding_run()

    # Turn
    log.info("— Turn —")
    poker.burn(1)
    poker.addCards(1)
    rnd.bidding_run()

    # River
    log.info("— River —")
    poker.burn(1)
    poker.addCards(1)
    rnd.bidding_run()

    # Showdown
    log.info("— Showdown —")
    evals = []
    for pl in players:
        he = poker.evaluateHand(pl.hand)
        evals.append((pl, he))
        log.info(f"{pl.name} hand: {pl.hand.cards} | best: {he}")
        print(f"{pl.name} hand: {pl.hand.cards} | best: {he}")

    winner = max(evals, key=lambda t: t[1].key())
    msg = f"Winner: {winner[0].name} with {winner[1].hand_rank.name}"
    log.info(msg)
    print(f"\n{msg}")


==== ./piwo1.py ====
# piwo1.py
import logging
from typing import List
from lib.Player import Player, Action, Command, Card, CardRank

log = logging.getLogger(__name__)

# ------- POMOCNICZE -------

def _street(board_len: int) -> str:
    if board_len == 0: return "preflop"
    if board_len == 3: return "flop"
    if board_len == 4: return "turn"
    return "river"

def _rank_counts(cards: List[Card]) -> dict[int, int]:
    counts = {}
    for c in cards:
        counts[c.rank.pips] = counts.get(c.rank.pips, 0) + 1
    return counts

def _preflop_score(hole: List[Card]) -> int:
    ## do ulepszenia
    """Minimalna ocena startówki: para + wysokie karty + suited/connected."""
    r1, r2 = hole[0].rank.pips, hole[1].rank.pips
    suited = hole[0].suit == hole[1].suit
    pair = r1 == r2
    hi, lo = (r1, r2) if r1 >= r2 else (r2, r1)
    connected = abs(r1 - r2) == 1

    s = 0
    if pair: s += 6 + (hi >= CardRank.TEN.pips)
    if hi >= CardRank.ACE.pips: s += 3
    if hi >= 13: s += 2
    if lo >= 10: s += 1
    if suited: s += 1
    if connected: s += 1
    return s

def _postflop_tier(hole: List[Card], board: List[Card]) -> str:
    """
    'air' (brak pary), 'pair', 'top_pair' (w tym overpair), 'two_pair_plus' (2p+).
    """
    if not board:
        return "air"

    all_cards = hole + board
    counts = _rank_counts(all_cards)

    # trips+ -> two_pair_plus
    if any(v >= 3 for v in counts.values()):
        return "two_pair_plus"

    # dwie różne pary wartości -> two_pair_plus
    pair_vals = [r for r, v in counts.items() if v >= 2]
    if len(pair_vals) >= 2:
        return "two_pair_plus"

    # jedna para: sprawdź top_pair/overpair
    if pair_vals:
        board_top = max(c.rank.pips for c in board)
        hole_pair = hole[0].rank.pips == hole[1].rank.pips
        overpair = hole_pair and (hole[0].rank.pips > board_top)
        top_pair = any(c.rank.pips == board_top for c in hole)
        if overpair or top_pair:
            return "top_pair"
        return "pair"

    return "air"

def _bet_delta_simple(street: str, min_raise: int) -> int:
    """Stałe, czytelne rozmiary raisów (delta do max_bet)."""
    table = {"flop": 20, "turn": 30, "river": 40}
    return max(table.get(street, 20), min_raise)

# --- NOWOŚĆ: wykrywanie flush draw (4 karty w kolorze) + semiblef ---
def _has_flush_draw(hole: List[Card], board: List[Card]) -> bool:
    """True, gdy mamy łącznie 4 karty w jednym kolorze i przynajmniej 1 nasza karta jest w tym kolorze."""
    if len(board) < 3:
        return False
    suit_counts = {}
    for c in hole + board:
        suit_counts[c.suit] = suit_counts.get(c.suit, 0) + 1
    for suit, cnt in suit_counts.items():
        if cnt >= 4 and any(h.suit == suit for h in hole):
            return True
    return False

# ------- BOT -------

class Piwo1(Player):
    """
    Prosty, bazowy bot + jedna poprawka:
    - Preflop: open/call/fold wg prostego score; vs raise -> 3-bet tylko top, inaczej call/fold.
    - Postflop: value-only; bet para/top_pair/2p+, brak blefów...
    - ... + NOWOŚĆ: jeśli mamy flush draw i 'air', gramy SEMIBLEF (mały bet) albo tani call vs bet.
    """
    _BB = 20  # zgodnie z Twoim main.py

    def play(self) -> Action:
        p = self.perspective_log[-1]
        hole = self.hand.cards if self.hand else []
        board = p.board
        pot = p.stakes
        to_call = p.to_call
        min_raise = max(p.min_raise, self._BB)

        st = _street(len(board))
        log.debug("[Piwo1] %s | hole=%s | board=%s | pot=%d | to_call=%d | min_raise=%d",
                  st, hole, board, pot, to_call, min_raise)

        # -------- PRE-FLOP --------
        if st == "preflop":
            s = _preflop_score(hole)
            log.debug("[Piwo1] Preflop score=%d", s)

            if to_call == 0:
                if s >= 5:
                    a = Action(Command.RAISE, max(2 * self._BB, min_raise))
                    log.info("[Piwo1] Preflop open-raise: %s", a)
                    return a
                elif s >= 3:
                    a = Action(Command.CALL)
                    log.info("[Piwo1] Preflop limp/check: %s", a)
                    return a
                else:
                    log.info("[Piwo1] Preflop fold.")
                    return Action(Command.FOLD)

            if s >= 7:
                a = Action(Command.RAISE, max(3 * self._BB, min_raise))
                log.info("[Piwo1] Preflop 3-bet (value): %s", a)
                return a
            elif s >= 4:
                a = Action(Command.CALL)
                log.info("[Piwo1] Preflop call vs raise: %s", a)
                return a
            else:
                log.info("[Piwo1] Preflop fold vs raise.")
                return Action(Command.FOLD)

        # -------- POST-FLOP --------
        tier = _postflop_tier(hole, board)
        has_fd = _has_flush_draw(hole, board)
        log.debug("[Piwo1] Postflop tier=%s | flush_draw=%s", tier, has_fd)

        # Nikt nie betował → możemy betować value; z 'air' tylko semiblef z flush drawem
        if to_call == 0:
            if tier == "air":
                if has_fd and st in ("flop", "turn"):
                    a = Action(Command.RAISE, _bet_delta_simple(st, min_raise))
                    log.info("[Piwo1] %s semiblef (flush draw): %s", st, a)
                    return a
                log.info("[Piwo1] %s check (brak value).", st)
                return Action(Command.CALL)  # check

            if tier == "pair":
                a = Action(Command.RAISE, _bet_delta_simple(st, min_raise))
                log.info("[Piwo1] %s value bet (para): %s", st, a)
                return a

            if tier == "top_pair":
                base = _bet_delta_simple(st, min_raise)
                a = Action(Command.RAISE, max(base, int(1.5 * base)))
                log.info("[Piwo1] %s value bet (top pair): %s", st, a)
                return a

            # two_pair_plus
            base = _bet_delta_simple(st, min_raise)
            a = Action(Command.RAISE, max(base, 2 * base))
            log.info("[Piwo1] %s value bet (two pair+): %s", st, a)
            return a

        # Rywal betuje → reagujemy prosto; draw traktujemy jak „air+, ale z equity”
        if tier == "air":
            if has_fd and st in ("flop", "turn"):
                # Tani call z drawem: nie płać za dużo (tu: do ~60% „puli” w Twojej metryce)
                threshold = 0.6 * (pot + to_call)
                if to_call <= threshold:
                    log.info("[Piwo1] %s call (flush draw).", st)
                    return Action(Command.CALL)
            log.info("[Piwo1] %s fold vs bet (air).", st)
            return Action(Command.FOLD)

        if tier == "pair":
            if st == "river":
                log.info("[Piwo1] River fold (sama para bez top).")
                return Action(Command.FOLD)
            log.info("[Piwo1] %s call (para).", st)
            return Action(Command.CALL)

        if tier == "top_pair":
            log.info("[Piwo1] %s call (top pair).", st)
            return Action(Command.CALL)

        # two_pair_plus: value-raise
        base = _bet_delta_simple(st, min_raise)
        a = Action(Command.RAISE, max(base, int(1.5 * base)))
        log.info("[Piwo1] %s raise (two pair+): %s", st, a)
        return a


==== ./skrypt.py ====
import os

def save_files_content_to_txt(root_folder, output_file):
    """Rekurencyjnie odczytuje pliki .c, .h i MAKEFILE w folderach
    i zapisuje ich treść do pliku tekstowego."""
    with open(output_file, 'w', encoding='utf-8') as outfile:
        for root, _, files in os.walk(root_folder):
            for file in files:
                # Sprawdź rozszerzenia plików i nazwę MAKEFILE
                if file.endswith(('.py')) or file.upper() == 'MAKEFILE':
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, 'r', encoding='utf-8') as infile:
                            outfile.write(f"==== {file_path} ====\n")
                            outfile.write(infile.read())
                            outfile.write("\n\n")
                    except Exception as e:
                        print(f"Nie udało się odczytać pliku {file_path}: {e}")

if __name__ == "__main__":
    # Zmień 'input_folder' na folder, który chcesz przeszukać
    input_folder = "./"
    output_file = "output.txt"
    save_files_content_to_txt(input_folder, output_file)
    print(f"Zawartość plików została zapisana do {output_file}")

==== ./lib\Player.py ====
from enum import Enum
from typing import List


class Command(Enum):
    FOLD = "fold"
    CALL = "call"
    RAISE = "raise"
    ALL_IN = "all_in"


class Action:
    def __init__(self, command_type: Command, raise_amount: int = 0):
        self.command_type = command_type
        self.raise_amount = raise_amount

    def __repr__(self):
        return f"Action({self.command_type.name}, {self.raise_amount})"


class PlayerType(Enum):
    SMALL_BLIND = "small_blind"
    BIG_BLIND = "big_blind"
    REGULAR = "regular"


class CardRank(Enum):
    TWO = "2"
    THREE = "3"
    FOUR = "4"
    FIVE = "5"
    SIX = "6"
    SEVEN = "7"
    EIGHT = "8"
    NINE = "9"
    TEN = "10"
    JACK = "J"
    QUEEN = "Q"
    KING = "K"
    ACE = "A"

    @property
    def pips(self) -> int:
        mapping = {
            CardRank.TWO: 2, CardRank.THREE: 3, CardRank.FOUR: 4, CardRank.FIVE: 5,
            CardRank.SIX: 6, CardRank.SEVEN: 7, CardRank.EIGHT: 8, CardRank.NINE: 9,
            CardRank.TEN: 10, CardRank.JACK: 11, CardRank.QUEEN: 12, CardRank.KING: 13,
            CardRank.ACE: 14
        }
        return mapping[self]


class CardSuit(Enum):
    HEARTS = "♥"
    DIAMONDS = "♦"
    CLUBS = "♣"
    SPADES = "♠"


class Card:
    def __init__(self, rank: CardRank, suit: CardSuit):
        self.rank = rank
        self.suit = suit

    def __repr__(self):
        return f"{self.rank.value}{self.suit.value}"


class HandRank(Enum):
    HIGH_CARD = 1
    PAIR = 2
    TWO_PAIR = 3
    THREE_OF_A_KIND = 4
    STRAIGHT = 5
    FLUSH = 6
    FULL_HOUSE = 7
    FOUR_OF_A_KIND = 8
    STRAIGHT_FLUSH = 9
    ROYAL_FLUSH = 10


class HandEvaluation:
    """
    value_cards: lista wartości (int) istotnych dla układu
    kicker_cards: pozostałe „kikery” malejąco
    """
    def __init__(self, hand_rank: HandRank, value_cards: List[int], kicker_cards: List[int] | None = None):
        self.hand_rank = hand_rank
        self.value_cards = value_cards
        self.kicker_cards = kicker_cards or []

    def key(self):
        return (self.hand_rank.value, self.value_cards, self.kicker_cards)

    def __lt__(self, other: "HandEvaluation"):
        return self.key() < other.key()

    def __repr__(self):
        return f"HandEvaluation({self.hand_rank.name}, {self.value_cards}, {self.kicker_cards})"


# lib/Player.py

class Perspective:
    def __init__(
        self,
        stack: List[Card],
        stakes: int,
        action_log: List[Action],
        board: List["Card"] | None = None,
        to_call: int = 0,
        max_bet: int = 0,
        min_raise: int = 0,
        position: int = 0
    ):
        self.stack = stack
        self.stakes = stakes
        self.action_log = action_log

        self.board = board or []
        ## Dodaję je teraz:
        self.to_call = to_call           # how much the player needs to call
        self.max_bet = max_bet           # current max bet
        self.min_raise = min_raise       # minimum allowed raise
        self.position = position         # player index


    def __len__(self):
        return len(self.action_log)

    def add_action(self, action: Action):
        self.action_log.append(action)

    def remove_first_action(self):
        if self.action_log:
            self.action_log = self.action_log[1:]


class Hand:
    def __init__(self, cards: List[Card]):
        self.cards = cards

    def __repr__(self):
        return f"Hand({self.cards})"


class RoundResult:
    def __init__(self, winner: str, pot: int, hands: List[Hand], isCardReset: bool = False):
        self.winner = winner
        self.pot = pot
        self.hands = hands
        self.isCardReset = isCardReset


class Player:
    def __init__(self, name: str, history: List[RoundResult], money: int, hand: Hand | None, perspective: Perspective):
        self.name = name
        self.history = history
        self.money = money
        self.hand = hand
        self.perspective_log: List[Perspective] = [perspective]

    def setHand(self, hand: Hand):
        self.hand = hand

    def accept(self, perspective: Perspective) -> Action:
        self.perspective_log.append(perspective)
        return self.play()

    def play(self) -> Action:
        # Placeholder, bot będzie tutaj grał
        return Action(Command.CALL)


==== ./lib\Poker.py ====
from typing import List
from collections import Counter
from itertools import combinations
import logging

import numpy as np

from .Player import (
    Card, CardRank, CardSuit, Hand, HandRank, HandEvaluation, Player
)

log = logging.getLogger(__name__)


class Poker:
    def __init__(self, players: List[Player]):
        self._available_deck: List[Card] = []
        self._initialized = False
        self._community_cards: List[Card] = []
        self._players = players

    def isInitialized(self):
        return self._initialized

    def initializeDeck(self):
        self._initialized = True
        self._available_deck = [Card(rank, suit) for rank in CardRank for suit in CardSuit]
        np.random.shuffle(self._available_deck)
        self._community_cards = []
        log.debug("Talia zainicjalizowana i potasowana. Liczba kart: %d", len(self._available_deck))

    def dealCards(self):
        def drawCard():
            if not self._available_deck:
                raise ValueError("No cards left in the deck")
            return self._available_deck.pop()

        for player in self._players:
            player.setHand(Hand([drawCard() for _ in range(2)]))
            log.debug("Rozdano %s: %s", player.name, player.hand.cards)

    def burn(self, n=1):
        burned = []
        for _ in range(n):
            if self._available_deck:
                burned.append(self._available_deck.pop())
        if burned:
            log.info("Spalono %d kart: %s", len(burned), burned)

    def addCards(self, num_cards=1):
        added = []
        for _ in range(num_cards):
            if not self._available_deck:
                raise ValueError("Not enough cards in deck")
            card = self._available_deck.pop()
            self._community_cards.append(card)
            added.append(card)
        log.info("Dokryto %d kart wspólnych: %s | Board: %s", num_cards, added, self._community_cards)

    def getCards(self):
        return list(self._community_cards)

    def isFull(self):
        return len(self._community_cards) >= 5

    def evaluateHand(self, player_hand: Hand) -> HandEvaluation:
        all_cards = player_hand.cards + self._community_cards

        if len(all_cards) < 5:
            raise ValueError("Need at least 5 cards to evaluate hand")

        best_hand = None
        for five_cards in combinations(all_cards, 5):
            hand_eval = self._evaluate_five_cards(list(five_cards))
            if best_hand is None or best_hand < hand_eval:
                best_hand = hand_eval

        return best_hand

    def _evaluate_five_cards(self, cards: List[Card]) -> HandEvaluation:
        ranks = [c.rank.pips for c in cards]
        suits = [c.suit for c in cards]

        rank_counts = Counter(ranks)
        suit_counts = Counter(suits)

        sorted_ranks = sorted(ranks, reverse=True)
        is_flush = len(suit_counts) == 1
        straight_high = self._straight_high(sorted_ranks)

        # Royal / Straight Flush
        if is_flush and straight_high is not None:
            if straight_high == 14 and set(sorted_ranks) == {10, 11, 12, 13, 14}:
                return HandEvaluation(HandRank.ROYAL_FLUSH, [14, 13, 12, 11, 10], [])
            return HandEvaluation(
                HandRank.STRAIGHT_FLUSH,
                [straight_high, straight_high - 1, straight_high - 2, straight_high - 3, straight_high - 4],
                []
            )

        # Four of a kind
        if 4 in rank_counts.values():
            four = max([r for r, cnt in rank_counts.items() if cnt == 4])
            kicker = max([r for r, cnt in rank_counts.items() if cnt == 1])
            return HandEvaluation(HandRank.FOUR_OF_A_KIND, [four], [kicker])

        # Full house
        if 3 in rank_counts.values() and 2 in rank_counts.values():
            three = max([r for r, cnt in rank_counts.items() if cnt == 3])
            pair = max([r for r, cnt in rank_counts.items() if cnt == 2])
            return HandEvaluation(HandRank.FULL_HOUSE, [three, pair], [])

        # Flush
        if is_flush:
            return HandEvaluation(HandRank.FLUSH, sorted_ranks, [])

        # Straight
        if straight_high is not None:
            return HandEvaluation(
                HandRank.STRAIGHT,
                [straight_high, straight_high - 1, straight_high - 2, straight_high - 3, straight_high - 4],
                []
            )

        # Three of a kind
        if 3 in rank_counts.values():
            three = max([r for r, cnt in rank_counts.items() if cnt == 3])
            kickers = sorted([r for r, cnt in rank_counts.items() if cnt == 1], reverse=True)
            return HandEvaluation(HandRank.THREE_OF_A_KIND, [three], kickers)

        # Two pair
        pairs = sorted([r for r, cnt in rank_counts.items() if cnt == 2], reverse=True)
        if len(pairs) >= 2:
            pairs = pairs[:2]
            kicker = max([r for r, cnt in rank_counts.items() if cnt == 1])
            return HandEvaluation(HandRank.TWO_PAIR, pairs, [kicker])

        # Pair
        if 2 in rank_counts.values():
            pair = max([r for r, cnt in rank_counts.items() if cnt == 2])
            kickers = sorted([r for r, cnt in rank_counts.items() if cnt == 1], reverse=True)
            return HandEvaluation(HandRank.PAIR, [pair], kickers)

        # High card
        return HandEvaluation(HandRank.HIGH_CARD, [sorted_ranks[0]], sorted_ranks[1:])

    @staticmethod
    def _straight_high(sorted_desc_ranks: List[int]) -> int | None:
        """
        Zwraca najwyższą kartę strita w 5 kartach lub None.
        Obsługuje wheel (A-2-3-4-5): zwraca 5 jako high.
        """
        unique = sorted(set(sorted_desc_ranks), reverse=True)
        if len(unique) != 5:
            return None

        if all(unique[i] - 1 == unique[i + 1] for i in range(4)):
            return unique[0]

        if set(unique) == {14, 5, 4, 3, 2}:
            return 5
        return None


==== ./lib\Round.py ====
from typing import List
import logging

from .Player import Player, Perspective, Command, Action
from .Poker import Poker

log = logging.getLogger(__name__)

class Round:
    def __init__(self, poker: Poker, players: List[Player], small_blind: int = 10, big_blind: int = 20):
        self.poker = poker
        self.players = players
        self.round_number = 1
        self.bets = [0 for _ in players]
        self.max_bet = 0
        self.small_blind = small_blind
        self.big_blind = big_blind

    def bidding_run(self):
        board = self.poker.getCards()
        street = {0: "preflop", 3: "flop", 4: "turn"}.get(len(board), "river")

        self.max_bet = 0
        self.bets = [0 for _ in self.players]

        if street == "preflop":
            self.bets[0] = self.small_blind
            self.bets[1] = self.big_blind
            self.max_bet = self.big_blind
            log.info("Post blinds: %s(SB)=%d, %s(BB)=%d",
                     self.players[0].name, self.small_blind,
                     self.players[1].name, self.big_blind)

        log.info("Licytacja: %s | start: pot=%d, max_bet=%d", street, sum(self.bets), self.max_bet)

        for idx, player in enumerate(self.players):
            pot = sum(self.bets)
            board = self.poker.getCards()

            to_call = self.max_bet - self.bets[idx]
            if to_call < 0:
                to_call = 0

            min_raise = self.big_blind

            persp = Perspective(
                stack=[],
                stakes=pot,
                action_log=[],
                board=board,
                to_call=to_call,
                max_bet=self.max_bet,
                min_raise=min_raise,
                position=idx
            )

            log.info("Gracz %s: to_call=%d, pot=%d, max_bet=%d, bets=%s, board=%s",
                     player.name, to_call, pot, self.max_bet, self.bets, board)

            action_done: Action = player.accept(persp)
            log.info("Gracz %s zagrywa: %s", player.name, action_done)

            if action_done.command_type == Command.FOLD:
                log.info("Gracz %s folduje (bez zmiany stawek).", player.name)
                continue
            elif action_done.command_type in (Command.CALL, Command.ALL_IN):
                to_call_now = self.max_bet - self.bets[idx]
                if to_call_now < 0:
                    to_call_now = 0
                self.bets[idx] += to_call_now
                log.info("CALL/ALL_IN: %s dopłaca %d -> bets=%s (max_bet=%d)",
                         player.name, to_call_now, self.bets, self.max_bet)
            elif action_done.command_type == Command.RAISE:
                self.max_bet += action_done.raise_amount
                self.bets[idx] = self.max_bet
                log.info("RAISE: %s podbija o +%d -> max_bet=%d, bets=%s",
                         player.name, action_done.raise_amount, self.max_bet, self.bets)

        log.info("Koniec licytacji %s: pot=%d, max_bet=%d, bets=%s",
                 street, sum(self.bets), self.max_bet, self.bets)


==== ./lib\__init__.py ====


